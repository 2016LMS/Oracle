# Oracle
## 实验一

* 查询语句①
```

SELECT d.department_name，count(e.job_id)as "部门总人数"，
avg(e.salary)as "平均工资"
from hr.departments d，hr.employees e
where d.department_id = e.department_id
and d.department_name in ('IT'，'Sales')
GROUP BY department_name;

```
查询语句①用时0.037s；
![](https://github.com/2016LMS/Oracle/blob/master/1.1.png)

* 查询语句②
```

SELECT d.department_name，count(e.job_id)as "部门总人数"，
avg(e.salary)as "平均工资"
FROM hr.departments d，hr.employees e
WHERE d.department_id = e.department_id
GROUP BY department_name
HAVING d.department_name in ('IT'，'Sales');

```
![](https://github.com/2016LMS/Oracle/blob/master/test1/1.png)
  查询语句②用时0.061s;
* 这两段查询语句的目的都是从d和e表中查询出“IT”和“Sales”部门的总人数和平均工资；而不同之处就是where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。
* 优化建议：
![](https://github.com/2016LMS/Oracle/blob/master/1.2.png)
